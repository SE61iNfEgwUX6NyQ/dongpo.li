---
title: "ExtensionLoader"
date: 2021-04-15T17:46:07+08:00
draft: true
---

dubbo提供扩展功能依赖的是自己实现的SPI机制,原理类似JDK的SPI.这次我们啃一下这块.
<!--more-->

# 开始
dubbo的启动类DubboBootstrap的构造函数中ApplicationModel.getConfigManager()这行其实就是ExtensionLoader的最早使用,所以ExtensionLoader还是初始化比较早的.

# ExtensionLoader
我们的惯例是先看构造方法,可以看到构造方法里传达了两个信息

1. 构造方法是private的所以肯定不是new对象使用的(基本算是废话因为ApplicationModel.getConfigManager()里就能看到ExtensionLoader.getExtensionLoader(FrameworkExt.class)这就是用法)
2. 如果传的type是ExtensionFactory的话this.objectFactory = null.


# getExtensionLoader()
这个方法比较简单,先做了参数校验略过,然后就是把一个static的Map中取某个类是不是有对应的缓存,没有就new一个ExtensionLoader放进去下次直接用.

所以这块代码里就一个重点,ExtensionLoader的构造方法.也就是这一行

``` java
objectFactory = (type == ExtensionFactory.class ? null : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension())
```
可以看到,如果需要的是ExtensionFactory类型的ExtensionLoader,objectFactory就是null,否则的话objectFactory=ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension()

# getAdaptiveExtension()
从上边的代码看,重点转到了ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension()

getExtensionLoader()方法上边说了返回一个ExtensionLoader实例,其中type=ExtensionFactory.class,objectFactory=null





